// Copyright (c) 2018-present Anbillon Team (anbillonteam@gmail.com).

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"anbillon.com/sqlbrick/cmd/sqlbrick/parser"
	"github.com/gobuffalo/packr"
	"golang.org/x/tools/imports"
)

const (
	sqlbrickTemplate = "sqlbrick.tpl"
	brickTemplate    = "brick.tpl"
	ddlTemplate      = "ddl.tpl"
	insertTempalate  = "insert.tpl"
	deleteTempalate  = "delete.tpl"
	updateTempalate  = "update.tpl"
	selectTemplate   = "select.tpl"
)

var templates = map[parser.QueryType]string{
	parser.QueryTypeInvalid: ddlTemplate,
	parser.QueryTypeInsert:  insertTempalate,
	parser.QueryTypeDelete:  deleteTempalate,
	parser.QueryTypeUpdate:  updateTempalate,
	parser.QueryTypeSelect:  selectTemplate,
}

// Type definition for sqlbrick generator.
type Generator struct {
	buf         bytes.Buffer
	box         packr.Box
	outputDir   string
	packageName string
}

// Type definition for sql functions used to generate sql func.
type SqlFunc struct {
	BrickName string
	FuncName  string
	Query     string
	ArgName   string
	Args      []string
	TotalArgs int
}

// NewGenerator create a new Generator with output dir and package name.
func NewGenerator(outputDir string, packageName string) *Generator {
	g := &Generator{
		box:         packr.NewBox("./templates"),
		outputDir:   outputDir,
		packageName: packageName,
	}

	return g
}

// header add common headers in output files.
func (g *Generator) header(source string) {
	g.Printf("// Copyright (c) 2018-present Anbillon Team (anbillonteam@gmail.com).")
	g.NewLine()
	g.Printf("// Code generated by sqlbrick. DO NOT EDIT IT.")
	g.NewLine()
	g.NewLine()
	if len(source) != 0 {
		g.Printf(fmt.Sprintf("// This file is generated from: %v", source))
		g.NewLine()
		g.NewLine()
	}
	g.Printf("package " + g.packageName)
	g.NewLine()
}

// Printf will add one line into the generator buffer.
func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// NewLine will add a new line to the generator buffer.
func (g *Generator) NewLine() {
	g.Printf("\n")
}

// applyTemplate will apply data into template
func (g *Generator) applyTemplate(tplName string, data interface{}) error {
	tpl, err := template.New("").Parse(g.box.String(tplName))
	if err != nil {
		return err
	}
	return tpl.Execute(&g.buf, data)
}

// GenerateSqlBrick will add sql brick definition into the generator buffer.
func (g *Generator) GenerateSqlBrick(bricks []string) {
	if err := g.applyTemplate(sqlbrickTemplate, struct {
		Bricks []string
	}{
		Bricks: bricks,
	}); err != nil {
		log.Printf("error: %v", err)
	}
}

// GenerateBrick will add brick definition into the generator buffer.
func (g *Generator) GenerateBrick(sourceFilename string, brick string, syntaxes []parser.Syntax) {
	if err := g.applyTemplate(brickTemplate, struct {
		SourceFilename string
		BrickName      string
		Syntaxes       []parser.Syntax
	}{
		SourceFilename: sourceFilename,
		BrickName:      brick,
		Syntaxes:       syntaxes,
	}); err != nil {
		log.Printf("error: %v", err)
	}
}

// Generate will add func into the generator buffer.
func (g *Generator) Generate(brickName string, funcName string,
	statement parser.Statement) {
	tpl, found := templates[statement.QueryType]
	if !found {
		log.Printf("no template found for given query: %v", statement.Query)
		return
	}
	var argName = "args"
	argsLen := statement.Args
	if len(argsLen) == 1 {
		argName = statement.Args[0]
	}

	if err := g.applyTemplate(tpl, SqlFunc{
		BrickName: brickName,
		FuncName:  funcName,
		Query:     statement.Query,
		ArgName:   argName,
		TotalArgs: len(statement.Args),
	}); err != nil {
		log.Printf("error: %v", err)
	}
	g.NewLine()
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format(outputFilename string) []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}

	importedSrc, err := imports.Process(outputFilename, src, nil)
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
	}

	return importedSrc
}

// Output will create a source code file and write all code.
func (g *Generator) Output(filename string) error {
	if err := os.MkdirAll(g.outputDir, os.ModePerm); err != nil {
		return err
	}
	outputFilename := filepath.Join(g.outputDir, strings.ToLower(filename))
	return ioutil.WriteFile(outputFilename, g.format(outputFilename), 0644)
}
