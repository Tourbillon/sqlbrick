// {{ .FuncName }} {{ if eq .Comment "" }}generated by sqlbrick, delete data from database.
// Affected rows will return if there's no error.
{{- else -}}
{{ .Comment }}
{{- end }}
{{ if .IsTx -}}
func (b *{{ .BrickName }}BrickTx){{ .FuncName }}({{ .ArgName }} interface{}) (int64, error) {
{{- else -}}
func (b *{{ .BrickName }}Brick){{ .FuncName }}({{ .ArgName }} interface{}) (int64, error) {
{{- end -}}
    {{- $query := index .Segments 0 -}}
    {{- $len := len $query -}}
    {{- if gt $len 40 }}
    {{- if .IsTx }}
    stmt, err := b.tx.PrepareNamed(
            `{{ $query }}`)
    {{- else }}
    stmt, err := b.db.PrepareNamed(
        `{{ $query }}`)
    {{- end }}
    {{- else }}
    {{- if .IsTx }}
    if err := b.checkTx(); err != nil {
        return 0, err
    }

    stmt, err := b.tx.PrepareNamed(`{{ $query }}`)
    {{- else }}
    stmt, err := b.db.PrepareNamed(`{{ $query }}`)
    {{- end }}
    {{- end }}
    if err != nil {
        return 0, err
    }

    {{ if eq .TotalArgs 1 -}}
    // create map arguments for sqlx
    args := map[string]interface{}{
    {{- range $k, $v := .Args }}
    {{ $mk := ToSnake $v }}"{{ $mk }}": {{ $v }},
    {{- end }}
    }
    {{ end }}

    result, err := stmt.Exec(args)
    if err != nil {
    {{- if .IsTx -}}
        if rbe := b.tx.Rollback(); rbe != nil {
            return 0, rbe
        }
    {{- end }}
        return 0, err
    }

    return result.RowsAffected()
}
