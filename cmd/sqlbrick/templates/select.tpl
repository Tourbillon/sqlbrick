// {{ .FuncName }} {{ if eq .Comment "" }}generated by sqlbrick, select data from database.{{ else }}{{ .Comment }}{{ end }}{{ if gt .TotalArgs 0 }}
func (b *{{ .BrickName }}Brick){{ .FuncName }}(dest interface{}, {{ .ArgName }} interface{}) error {
    stmt, err := b.db.PrepareNamed(
        `{{ index .Segments 0 }}`)
    if err != nil {
        return err
    }

    // create map arguments for sqlx
    args := map[string]interface{}{
    {{ range $k, $v := .Args }}"{{ $v }}": {{ $v }},{{ end }}
    }
    {{ if eq .Mapper 1 }}
    row := stmt.QueryRowx(args)
    if row.Err() != nil {
    	return row.Err()
    }

    return row.StructScan(dest)
    {{ else }}
    rows, err := stmt.Queryx(args)
    if err != nil {
        return err
    }

    return sqlx.StructScan(rows, dest){{ end }}
}
{{ else }}
func (b *{{ .BrickName }}Brick){{ .FuncName }}(dest interface{}) error {
    return b.db.Select(dest, `{{ index .Segments 0 }}`)
}
{{ end }}